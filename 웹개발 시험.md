### Java로 hello world를 출력하는 main 메소드를 작성하시오.

> 정답률 30%

- main 메소드를 작성할 줄 아는 것은 이 분야에 발을 담그는 것에 대한 최소한의 예의(?)라고 생각해서 출제
- 약간의 오타는 감안할 수 있으나 public static void main은 절대로 틀리면 안 됨

------

### alz로 압축을 하거나, hwp로 문서를 작성하여 외국에 전송하면 안 되는 이유를 설명하시오.

> 정답률 90%

- 외국에서 사용하지 않는다 혹은 표준이 아니라는 등의 답변을 쓰면 정답으로 인정

------

### for문을 사용하여 1에서 10까지의 합을 구하는 프로그램을 작성하시오. (main 메소드 불필요)

> 정답률 60%

- 기초적인 문법을 숙지하고 있는지 평가
- 대부분 부호를 잘못 써서 틀림 (1에서 10까지 더하라면 0<=10 또는 0<11로 써야 함)
- 변수 선언을 하지 않아도 정답으로 인정함

------

### 다음은 javadoc의 String.replaceAll 메소드에 대한 설명이다. 우리말로 해석하시오.

> 정답률 15%

Replaces each substring of this string that matches the given regular expression with the given replacement.

- 영어로 된 문서를 보고 이해할 수 있는지 평가
- 정규표현식의 번역을 몰라서 regular expression으로 그대로 둬도 정답으로 인정

------

### 리눅스를 설치해보신 적이 있습니까? 설치해 본 제품명을 기술하시오. 또한 어떠한 용도로 사용해 보았는지 기술하시오.

> 정답률 40%

- 종류와 버전을 불문하고 리눅스를 설치해본 경험이 있다고 하면 정답으로 인정
- OS 경험도 점수로 인정하는 편이 좋다고 생각했음

------

### 다음 빈칸을 채우시오.

(-----------------------) is a programming paradigm that uses "objects" – data structures consisting of data fields and methods together with their interactions – to design applications and computer programs. Programming techniques may include features such as data abstraction, encapsulation, modularity, polymorphism, and inheritance. Many modern programming languages now support (-----------------------)

> 정답률 20%

- 한글로 "객체지향프로그래밍" 또는 OOP로 쓰면 정답으로 인정
- 두 항목에 다른 대답을 쓰는 경우도 있었는데 그 경우 부분 점수를 인정

------

### 다음 주어진 div의 클래스를 정의하시오.

##### - 너비가 250px이고 높이가 300px이며, 배경색이 검은색인 hello 클래스

```
<div class="hello">안녕하세요</div>
<style type="text/css">
.hello {



}
</style>
```

> 정답률 25%

- 기초적인 CSS 문법을 알고 있는지 평가
- background나 background-color 모두 정답

------

### 세션과 쿠키의 차이점에 대해 간략히 설명하시오.

> 정답률 30%

- 서버와 클라이언트 차이에 대해 서술하면 정답으로 인정
- 라이프 사이클에 대한 설명이 있다면 금상첨화
- 세션이 보안적으로 안전하다는 데에는 이견이 있으나, 여기서는 그렇게 기술해도 정답으로 인정

------

### 다음 소스코드를 읽고 무엇을 하는 프로그램인지 서술하시오.

```
char[] arr = someString.toCharArray(); // 해당 문자열로부터 캐릭터 배열을 선언한다
StringBuffer sb = new StringBuffer();
int size = 0;
for(char c : arr) {
    size += (c > 255) ? 2 : 1; // 조건에 따라 2 또는 1을 증가시킨다
    sb.append(c);
    if(size >= 80) {
        break;
    }
}
return sb.toString();
```

> 정답률 10%

- char의 타입을 이해하고 있는지 평가
- 남이 짠 소스 코드를 읽을 수 있는지를 평가 (코드 리딩)
- 이 소스는 온전한 소스가 아니나 일부러 간략하게 만들었음

------

### 다음 javascript 소스코드가 어떻게 동작할지 서술하시오.

```
function f() {
    for ( var i = 0; i < 3; i++ ) {
        setTimeout( function() {
            alert( i );
        }, 1000);
    }
}
f(); // f를 실행한다
```

> 정답률 0%

- timer나 클로저를 이해하고 있는지 평가
- 이 문제는 일종의 덤임(신입 레벨에서 맞출 수 있는 사람이 있으리라고 기대하지 않음)
- 기대하지 않았다고 해도 이 문제를 대하는 태도와 답변에서 지원자의 많은 부분을 엿볼 수 있었음

------

### 다음 조건을 만족하는 SQL 질의문을 작성하시오.

사원번호(emp.seq), 이름(emp.name), 부서명(dept.name) 컬럼이 매핑되며, **모든 사원**이 전부 출력되어야 함

```
emp 테이블
------------------
seq | name | dept_seq
1 | 홍길동 | 2
2 | 죠나단 | 1
3 | 죠스타 | null

dept 테이블
------------------
seq | name
1 | 개발부
2 | 운영부

```

> 정답률 10%

- left outer join 문법을 이해하고 있는지 평가

### API란 ?

응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.

----

### 쿠키와 세션

쿠키는 자기 자신이 가지고 있고

- 키워드, 검색어 등등

세션은 서버에 넣어주는 것

- 세션은 해쉬 구조
- 중요한 것들을 넣어서 보관함 ex) 개인정보

#### 좀더 자세하게 알아보자 !

먼저 쿠키와 세션은 HTTP 프로콜의 약점을 커버하기 위해서 존재함.

HTTP 프로토콜은 Connectionless하고 Stateless하다라고 이야기함.

무슨 이야기냐?

- Connectionless: 클라이언트가 request를 서버에 보내면, 서버는 클라이언트에게 response를 하면 서로 접속을 끊는 특성.


- Stateless: 접속을 끝는 순간 클라이언트와 서버의 통신은 끝나고 상태 정보는 유지하지 않는 특성

이 두가지 특성이 장점이자 약점이 된다 !

장점은 통신을 유지하고 있으면 드는 모든 리소스 낭비를 줄일 수 있지만 !

But 통신을 할때마다 계속 내가 누구라는 인증을 해야함 ! 

그래서 ! 우리는 쿠키와 세션을 이용해서 해결함 !

#### 1. 쿠키

- 클라이언트에 저장되는 키와 값이 들어있는 작은 데이터 파일
- 쿠키는 이름, 값, 만료 날짜(쿠키 저장기간), 경로 정보가 들어있다.
- 쿠키는 일정 시간동안 데이터를 저장할 수 있어서 로그인 상태를 유지함.
- 쿠키는 클라이언트의 상태 정보를 본인 하드 디스크에 저장하였다가 필요할 때 참조, 재사용함.

#### 1. 2) 쿠키의 사용 예

- 방문 사이트에서 아이디와 비밀번호를 저장하시겠습니까? 라고 나타나는 것은 쿠키로 저장하겠냐 라는 뜻
- 팝업이 나타날때 "오늘 이 창을 보지 않음"을 누르면 오늘 그 창이 뜨지 않는 것.

#### 1.3) 쿠키의 제약조건

- 클라이언트에 총 300개까지 쿠키를 저장할 수 있음 !
- 하나의 도메인 당 20개의 값만 가질 수 있음 !
- 하나의 쿠키 값은 4MB까지 저장 가능 !

### 2. 세션

- 세션은 클라이언트와 웹 서버간 네트워크 연결이 지속 유지되고 있는 상태
- 즉, 사용자가 브라우저를 열어 서버에 접속한 뒤 접속을 종료할 때 시점까지를 말함.
- HTTP 프로토콜은 비접속형 프로토콜이므로, 매 접속시마다 새로운 네트워크 연결이 이루어지는데, 세션이 연결유지를 가능하게 해줌.
- 클라이언트가 웹서버에 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여, 이 ID를 세션이라고 부름
- 세션 ID는 임시로 저장하여 페이지 이동 시 이용하거나, 클라이언트가 재 접속 했을 때 클라이언트를 유일하게 구분하는 수단.

#### 2.2) 세션의 장점

- 각 클라이언트에게 고유 ID를 부여함 (정확한 구분)
- 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
- 서버에서 클라이언트롤 발급해준 세션 ID를 쿠키를 사용해서 저장
- 클라이언트는 다시 접속시, 이 쿠키를 이용해서 세션 ID값을 서버에 전달함.

#### 2.3) 세션의 단점

- 서버에 저장되는 세션때문에 서버에 처리를 요구하는 부하와 저장 공간을 필요함.

#### 2.4) 사용 예

- 로그인과 같이 보안상 중요한 작업은 세션을 통해서 작동함. 

#### 쿠키와 세션의 차이점

기본적으로 쿠키와 세션은 비슷한 역할을 함, 동작원리 또한 비슷, 왜냐하면 세션도 결국 쿠키로 저장해서 사용하기 때문이다.

그러나 큰 차이점은 저장되는 위치. 쿠키는 클라이언트에 저장되어서 보내는 역할을하고, 세션은 서버에 저장되어서 클라이언트에게 알려줘서 사용함. 

쿠키는 서버의 자원을 전혀 사용하지 않으며 클라이언트 단에서 저장을 해서 사용. 

세션은 서버에 저장되어서 그 고유한 ID를 가지고 있음. 그래서 서버의 자원을 사용

쿠키와 세션은 서버의 자원을 사용할 수 있음. 쿠키와 세션의 만료되는 기간도 다름.

쿠키는 클라이언트에 저장되어서 서버에 요청시 빠른 속도를 보냄. 세션은 서버에 정보가 있기때문에 서버의 처리가 필요해서 쿠키보다 느린 속도.

#### 보안성이 낮은 Cookie 대신 Session을 사용하면 되는데 안하는 이유?

A. 모든 정보를 **Session에 저장하면 Server의 메모리를 과도하게 사용하게 되어 Server에 무리**가 감

---

### 네트워크 전송 Get, Post 비교

GET, POST 방식의 request는 서버로 본인이 가지고 있는 data를 전달하기 위해 사용.

#### GET 방식

- 클라이언트로 입력한 query의 이름과 값이 결합되어 스트링 형태로 서버에 전달.
- <FROM>TAG의 METHOD 속성의 값으로 GET을 입력함
- DB에 추가로 정보를 처리하지않고, 저장된 Data를 단순 요청하는 정도로 사용
- Dependancy: POST<GET
- URL에 그대로 query의 이름과 값이 같이 연결되어 표현

#### POST방식

- 클라이언트와 서버 간에 인코딩하여 서버로 전송
- 헤더를 통해 요청이 전송되는 방식
- <FORM>TAG의 METHOD 속성의 값으로 POST를 입력
- 한번 요청시 데이터양은 제한 없음
- DB에 추가로 서버에서 갱신 작업을 할때, 서버에서 정보가 가공되어 응답하는 경우에 사용
- Dependancy : Post>Get
- 클라이언트에서 데이터를 이코딩 -> 서버측에서 디코딩해서 사용
- Query는 body안에 들어가 있어서 보안에 조금 유리함.

---

### 2. ORM(객체 관계 매핑) 이란 ? (Object-Relational Mappings)

**(ruby에서 대표적인건 datamapper)**

ORM이라는 것을 단순하게 표현해보자면 객체와 관계와의 설정? 정도일까? 그럼 여기서 말하는 객체라는 것은 우리가 흔히 말하는 OOP(Object-Oriented Programming)의 그 객체를 이야기 하는 것 이라면, 과연 관계라는 것이 의미하는 것은 무엇일까? 뭐 지극히 기초적인 이야기지만 우리(개발자)가 흔히 사용하고 있는 관계형 데이터베이스를 의미한다.

#### 결론 ! 코드를 통해서 데이터베이스를 조작하는 것 ! SQL을 사용하지 않고 !

####장점 [#](http://www.incodom.kr/ORM#h_ad297d8f97c26a598b96a9fde03f7b73)

- 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다.
  - 선언문, 할당, 종료 같은 부수적인 코드가 없거나 급격히 줄어든다.
  - 각종 객체에 대한 코드를 별도로 작성하기 때문에 코드의 가독성을 올려준다.
  - SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다.
- 재사용 및 유지보수의 편리성이 증가한다.
  - ORM은 독립적으로 작성되어있고, 해당 객체들을 재활용 할 수 있다.
  - 때문에 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리하다.
  - 매핑정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있다.
- DBMS에 대한 종속성이 줄어든다.
  - 대부분 ORM 솔루션은 DB에 종속적이지 않다.
  - 종속적이지 않다는것은 구현 방법 뿐만아니라 많은 솔루션에서 자료형 타입까지 유효하다.
  - 프로그래머는 Object에 집중함으로 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다.
  - 또한 자바에서 가공할경우 equals, hashCode의 오버라이드 같은 자바의 기능을 이용할 수 있고, 간결하고 빠른 가공이 가능하다.

####단점 [#](http://www.incodom.kr/ORM#h_db739aa439489091d2ff2f1ca5c004ec)

- 완벽한 ORM 으로만 서비스를 구현하기가 어렵다.
  - 사용하기는 편하지만 설계는 매우 신중하게 해야한다.
  - 프로젝트의 복잡성이 커질경우 난이도 또한 올라갈 수 있다.
  - 잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있다.
  - 일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는등 별도의 튜닝이 필요한 경우가 있다.
  - DBMS의 고유 기능을 이용하기 어렵다. (하지만 이건 단점으로만 볼 수 없다 : 특정 DBMS의 고유기능을 이용하면 이식성이 저하된다.)
- 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.
  - 이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 많이 발생할 수 있다.

---

###  심볼과 String의 차이

즉, 심볼도 객체이며, 문자열도 객체입니다. 그러나 symbol은 변경이 불가능(immutable)한 객체입니다. 다시말해, 심볼은 한번 값이 assign 되고 나면 값을 변경하는 것이 불가능합니다. 그렇다고 해서 객체자체가 Java의 final 선언된 변수와 같이 덮어쓸 수도 없다는 의미는 아닙니다. Immutable 이란, 객체가 가지고 있는 값을 변경(change)할 수는 없지만 덮어쓰기(overwrite)할 수는 있다는 의미입니다.

문자열은 변경이 가능(mutable) 하기 때문에, 루비 인터프리터는 실제 해당 문자열이 어떤 값을 가지고 있는지 실행시점까지 알 수 가 없습니다. 이것은 다시말해, 우리가 보기에는 동일한 문자열도 서로 다른 메모리 공간을 차지하고 있어야 한다는 의미입니다.

### 결론

루비에서 대부분의 경우 심볼을 문자열을 사용하는 경우보다 메모리 효율성이나 성능 측면에서 유리합니다. 이러한 이유로 hash의 키 등으로 문자열을 사용하는 것보다 심볼을 사용하는 것이 좋습니다.

대부분의 루비 개발자들은 해시의 키로 심볼을 사용하는 것이 익숙하지만, 왜 그렇게 해야하는지, 문자열 대신 심볼을 사용하는 것이 어떤한 면에서 유리한지는 한번 기억해 두는 것이 좋습니다.

---

### Socket이란 ?

- TCP/IP로 통신을 행하는 컴퓨터가 가지는 네트워크 내에서의 주소에 해당하는 IP어드레스와, IP어드레스의 서브 어드레스인 포트 번호를 조합한 네트워크 어드레스를 말한다.


- 소켓은 네트워크 상에서 클라이언트 프로그램과 서버 프로그램 사이의 통신 방법이다. 소켓은 "접속의 끝 부분"으로 정의된다.


- 소켓이란 네트워크상에서 서버와 클라이언트 두 개의 프로그램이 특정 포트를 통해 양방향 통신이 가능하도록 만들어주는 소프트웨어 장치라 말할 수 있다.

종합해보면, socket은 IP 어드레스와 포트 넘버가 합쳐진, 네트워크 상에서 서버 프로그램과 클라이언트 프로그램이 통신을 할 수 있도록 해주는 소프트웨어 장치.

---

### 채널 

채널은 일종의 게이트웨이이다. 기존의 파일이나 소켓 등에서 사용하던 스트림이 네이티브 IO 서비스를 이용할 수 있도록 도아주는 메소드를 제공한다. 하지만 채너은 기존의 스트림과 구별되는 몇 가지 큰 차이점이 존재한다. 채널은 데이터를 보내거나 데이터를 받기 위한 타겟으로 ByteBuffer를 사용한다는 점이다. ByteBuffer를 사용함으로써 직간접적으로 여러 가지 다양한 네이티브 서비스를 이용할 수 있기 때문이다. 

또 이렇게 채널을 통해 데이터를 주고 받으면, 운영체제 수준의 네이티브 IO 서비스들을 직간접적으로 이용할 수 있다는 점이다. 따라서 기본적으로 채널을 통한 IO 통신은 기존의 스트림보다 좀더 효율적이고 기존에 지원되지 않았던 메모리 맵 파일, 파일 락킹 같은 기능들도 이용할 수 있게 된다.

마지막으로 채널은 스트림과 달리 단방향 뿐만 아니라 양방향 통신도 가능하다. 항상 양방향 통신을 이용할 수 있는 것은 아니지만 소켓 채널의 경우 별다른 설정 없이 양방향 통신이 가능하지만 파일 챈ㄹ의 경우에는 그렇지 않다.

---

### HTML DOCTYPE 선언이유

HTML은 버전 별로 지원하는 태그가 조금씩 다르다. 그래서, HTML이 어떤 버전으로 작성되었는지 미리 선언해, 웹브라우저가 내용을 올바로 표시할 수 있도록 해주는 것이 <!DOCTYPE>이다 ! 

유형에 따라 마크업 문서의 요소와 속성등을 처리하는 기준이 되며 유효성 검사에 이용된다.

---

### MVC 패턴

#### MVC란?

- 객체지향프로그래밍에서, MVC란 사용자 인터페이스를 성공적이며 효과적으로 데이터 모형에 관련 시키기 위한 방법론 또는 설계 방식중 하나이다. MVC방식은 자바, Smalltalk,
- MVC 패턴은 목적 코드의 재사용에 유용한 것은 물론, 사용자 인터페이스와 응용프로그램 개발에 소요되는 시간을 현저하게 줄여주는 형식이라고 많은 개발자들이 평가하고 있다.

#### MVC 구성요소

**Model** 

- 소프트웨어 응용과 그와 관련된 고급 클래스 내의** 논리적 데이터 기반 구조를 표현**. 이 목적 모형은 사용자 인터페이스에 관한 어떠한 정보도 가지고 있지 않다.

**View **

- 사용자 인터페이스 내의 구성요소들을 표현(**사용자에게 보여지는 화면**)

**Controller **

- Model과 View를 연결하고 있는 클래스를 대표, **Model과 View 내의 클래스들 간 정보 교환**하는데 사용.

---

### HTTP란? (Hyper Text Transfer Protocol)

HTTP 는 브라우저가 웹 서버와 통신하기 위해 사용하는 주요 프로토콜이다. HTTP 4가지 요청 형식은 아래와 같다.

- GET : 문서를 요청. 서버가 클라이언트에 상태 정보와 복제된 문서를 보냄으로써 응답을 함. (조회)
- HEAD : 상태 정보를 요청. GET 과 동일한 형태로 응답을 하지만, 문서를 복제하지는 않는다.
- POST : 데이터를 서버로 송신. 서버는 해당 데이터를 특정 아이템에 덧붙인다. (생성)
- PUT : 데이터를 서버로 송신. 서버가 특정 아이템을 완전히 대체한다. (수정)

---

### 브라우저에서 캐싱하기

웹 페이지 성능을 최적화 하려면 캐시를 이용한다. 예를 들어, 용량이 큰 이미지가 많은 사이트를 반복 접속하는 경우에 다운로드 시간과 HTTP GET 요청수를 줄이기 위해 해당 이미지를 사용자의 디스크에 저장하고 캐시로 사용한다. 브라우저는 캐시가 최신 버전인지 이전 버전인지 어떻게 확인할까? 바로 캐시를 사용하기 전에 서버에 HEAD 요청을 날려 Last-Modified Date 를 비교해 최신임을 확인한다. 여기서 주의할 점은 모든 파일에 대해 캐시를 만드는 것이 더 효율적일지 아니면, HEAD 요청을 만들어 날리는 값들을 고려했을 때 캐시로 만들지 않는 것이 더 효율적일지 고민해야 한다. (캐시하려는 파일의 크기가 매우 작은 경우)

---

## FTP (File Transfer Protocol)

파일이 문서, 이미지, 프로그램 등 다양한 형태의 데이터를 갖고 있을 수 있기 때문에 컴퓨터 간의 파일 교환시에 호환성을 보장하는 프로토콜이 필요하다. 컴퓨터 간의 호환성이라는 것은 예를 들어, 한 컴퓨터에서는 JPEG 이미지가 .jpg 로 저장되지만 다른 컴퓨터에서는 .jpeg 로 저장될 수 있다. 또한 어떤 컴퓨터는 파일 경로를 (/) 를 사용하지만 다른 컴퓨터는 () 를 사용할 수도 있다. 이렇기 때문에 파일 전송에 대한 규약인 프로토콜을 이용하여 상호 컴퓨터 간에 파일 전송이 가능하다. FTP 의 특성은 다음과 같다.

- 어떤 형태의 데이터든 전송이 가능하다.
- 파일을 다운로드 & 업로드 할 수 있다.
- 파일에 대한 권한을 설정할 수 있다.
- ASCII 문자로 메시지가 교환된다.
- 파일을 검색하고 조회할 수 있다.

브라우저에서 파일을 다운로드 하게 되면 바로 FTP 프로토콜을 사용하게 된다.

## FTP 통신 방식

HTTP 와는 다르게 FTP 는 클라이언트에서 서버로 한번 연결을 맺어놓은 상태에서 파일을 주고 받는 것이 아니라. 클라이언트에서 서버와의 연결이 맺어지면, 해당 연결은 명령어 입력을 위해 남겨놓고 (Control Connection), 파일을 보낼 때 새로운 연결을 추가하여 파일을 전송한다. (File Connection)

---

## SMTP (Simple Mail Transfer Protocol)

메일 전송 프로그램이 서버로 메일을 보낼 때 사용하는 프로토콜이다. 오직 텍스트만 전송이 가능한 것이 특징이고, 스트림 방식을 이용하여 전송한다. SMTP 는 한 개의 메시지를 해당 서버의 여러 수신자에게 보낼 수 있다는 특징이 있다. 상태 코드는 250 (수신 성공), 550 (수신자 못 찾음)

## MIME (Multi-purpose Internet Mail Extensions)

SMTP 로 전송시 이메일에 텍스트 밖에 포함하지 못하는 단점을 보완하여, 메시지 안에 텍스트 이외의 데이터를 전송할 수 있는 프로토콜이다. 바이너리 파일을 출력 가능한 문자열 형태로 인코딩하고, 수신하는 부분에서 디코딩한다. Base64 로 인코딩 하기는 하지만, 다른 형태의 인코딩도 사용할 수 있다. 인코딩 방식은 메시지의 헤더 안에 정의한다. MIME 은 이메일 헤더에 2 줄을 추가하는데, 이메일에 MIME 이 사용되었는지 여부와 MIME 정보를 바디에 어떻게 포함시킬 건지 를 정의한다.

---

**[프록시 서버 (Proxy Server) ]**

클라이언트와 서버 사이에서 통신을 중계해 주는 컴퓨터나 프로그램을 말합니다. 프록시 서버의 주된 용도 중 하나는 빠른 전송을 위하여 서버의 응답 결과를 캐시에 저장해 두는 것입니다. 프록시 서버를 두는 두 번째 이유는 보안적인 부분인데, 첨단 기술을 다루는 회사의 경우 내부 사용자의 기밀 유출에 민감할 수밖에 없습니다. 이런 경우 프록시 서버를 이용하면 외부로 전달되는 데이터를 검사하여 특정 단어가 포함된 자료의 송.수신을 차단하거나 보안 팀에 경고 메시지를 보낼 수 있습니다.

 **[ 멀티 프로세스와 멀티 스레드 ]**

멀티 프로세스 방식은 클라이언트가 연결 요청을 하면 서버 프로그램은 자신을 복제하여 클라이언트에 대응하게 하고, 자신은 다른 클라이언트의 요청을 기다립니다. 이 방식은 원본 프로세스의 메모리를 모두 복제하기 때문에 자원 낭비가 심합니다. 그에 비해 멀티 스레드 방식은 클라이언트 요청을 처리하는 일부 코드만 별도로 분리하여 실행하기 때문에 전체 메모리를 복제할 필요가 없어, 멀티 프로세스 방식보다 메모리 낭비가 적습니다.

 **[ 요청 헤더 ]**

헤더에는 세 가지 종류가 있는데 요청이나 응답 모두에 적용할 수 있는 '일반 헤더(General-header)'와 요청 또는 응답 둘 중 하나에만 적용할 수 있는 '요청 헤더 또는 응답 헤더(Request-header/Response-header)', 보내거나 받는 본문 데이터를 설명하는 '엔티티 헤더(Entity-header)'가 있습니다. 요청 헤더가 담는 헤더명중 User-Agent가 있는데 클라이언트의 정보를 서버에게 알려주는 헤더입니다. 웹 서버는 이 헤더를 분석하여 요청자의 OS와 브라우저를 구분합니다. 

**[ CGI(Common Gateway Interface) ]**

웹 서버와 프로그램 사이의 데이터를 주고받는 규칙을 CGI(Common Gateway Interface)라고 합니다. 이렇게 웹 서버에 의해 실행되며 CGI 규칙에 따라서 웹 서버와 데이터를 주고 받도록 작성된 프로그램을 'CGI 프로그램'이라고 합니다. 

**[ 서블릿 컨테이너 ]**

서블릿의 생성과 실행, 소멸 등 생명주기를 관리하는 프로그램을 '서블릿 컨테이너(Servlet Container)'라 합니다. 서블릿 컨테이너(Jave EE 기술 중에서 서블릿, JSP 등 웹 관련 부분만 구현한 서버로 아파치 재단의 톰캣, Jetty등)가 서블릿을 대신하여 CGI 규칙에 따라 웹 서버와 데이터를 주고받습니다.

 **[ WebContent/Web-INF ]**

웹 애플리케이션의 설정과 관련된 파일을 두는 폴더로 이 폴더에 있는 파일은 클라이언트에서 요청할 수 없다. 따라서 HTML이나 JavaScript, CSS 등 클라이언트에서 요청할 수 있는 파일을 이 폴더에 두어서는 안 됩니다.

 **[ GET 요청으로 넘어온 매개변수 값의 인코딩 설정 ]**

GET 요청은 매개변수 값이 URL에 포함되기 때문에 setCharacterEncoding()으로는 문자 집합을 설정할 수 없다. 톰캣 서버에서 server.xml을 열어 <Connector>태그에 URIEncoding 속성을 추가하고, 값은 UTF-8로 설정한다. 웹 브라우저가 웹 서버로 데이터를 보낼 때는 웹 페이지의 기본 문자집합으로 인코딩하여 보내기 때문에 사용자가 입력한 값은 UTF-8로 인코딩되어 서버에 전달된다. 반면 서블릿은 UTF-8(한글 한 자를 3바이트로 표현) 3바이트를 하나의 문자로 인식하지 않고 각각의 바이트를 개별 문자로 취급하여 유니코드로 변환한다. 이렇기에 server.xml에 설정을 해주지 않을 경우 한글이 깨지게 된다.

 **[ SeverletContext 보관소 ]**

웹 애플리케이션이 시작될 때 생성되어 웹 애플리케이션이 종료될 때까지 유지된다. 이 보관소에 데이터를 보관하면 웹 애플리케이션이 실행되는 동안에는 모든 서블릿이 사용할 수 있다.

**[ HttpSession 보관소 ]**

클라이언트의 최초 요청 시 생성되어 브라우저를 닫을 때까지 유지됩니다. 보통 로그인할 때 이 보관소를 초기화하고, 로그아웃하면 이 보관소에 저장된 값들을 비웁니다. 따라서 이 보관소에 값을 보관하면 서블릿이나 JSP 페이지에 상관없이 로그아웃하기 전까지 계속 값을 유지할 수 있습니다. JSP에서는 session변수를 통해 이 보관소를 참조할 수 있습니다.

 **[ ServletRequest 보관소 ]**

클라이언트의 요청이 들어올 때 생성되어, 클라이언트에게 응답 할 때까지 유지됩니다. 이 보관소는 포워딩이나 인클루딩하는 서블릿들 사이에서 값을 공유할 때 유용합니다. JSP에서는 request변수를 통해 이 보관소를 참조할 수 있습니다.

 **[ JspContext 보관소 ]**

JSP 페이지를 실행하는 동안만 유지됩니다. JSP에서는 pageContext 변수를 통해 이 보관소를 참조할 수 있습니다.

**[ HttpSession ]**

HttpSession 객체는 클라이언트 당 한 개가 생성됩니다. 웹 브라우저로부터 요청이 들어오면, 그 웹 브라우저를 위한 HttpSession 객체가 있는지 검사하고, 없다면 새로 HttpSession 객체를 만듭니다. 이렇게 생성된 HttpSession 객체는 그 웹 브라우저로부터 일정 시간 동안 Timeout 요청이 없으면, 삭제됩니다.

 **[ JspContext의 활용 ]**

JSP 페이지를 작성하다 보면 <jsp:include>와 같은 특별한 태그를 사용하게 됩니다. 이런 태그들은 JSP 엔진이 서블릿 클래스를 생성할 때 특정 자바 코드로 변환됩니다. 이때 이 태그의 값을 다루는 객체를 '태그 핸들러'라고 부릅니다. 바로 이 태그 핸들러에게 데이터를 전달하고자 할 때 JspContext 보관소를 사용하는 것입니다.  JSP 페이지에 선언된 로컬 변수는 태그 핸들러에서 접근할 수 없습니다. 따라서 태그 핸들러에게 전달할 데이터가 아니라면 JspContext에 값을 보관할 필요가 없습니다.

**[ DI(Dependency Injection) ]**

작업에 필요한 객체를 외부로부터 주입 받는 것으로 다른 말로 역제어(IoC, Inversion of Control)'라고도 부릅니다.

---

## 2.DATABASE, TABLE 생성, 데이타 INSERT

### 2-1. DATABASE 생성

> 깨끗하게 hhddb를 생성하기 위해 사용포인트를 다른DB로 옮기고 기존 DB를 삭제하고 생성

```
USE tempdb;
DROP DATABASE hhddb;
CREATE DATABASE hhddb;
USE hhddb;

```

### 2-2. TABLE 생성

> 각 테이블 생성 
> Create Customers table

```
CREATE TABLE Customers
(
  cust_id      char(10 )  NOT NULL ,
  cust_name    char(50 )  NOT NULL ,
  cust_address char( 50)  NULL ,
  cust_city    char(50 )  NULL ,
  cust_state   char(5 )   NULL ,
  cust_zip     char(10 )  NULL ,
  cust_country char( 50)  NULL ,
  cust_contact char( 50)  NULL ,
  cust_email   char(255 ) NULL
);

```

> Create OrderItems table

```
CREATE TABLE OrderItems
(
  order_num  int          NOT NULL ,
  order_item int          NOT NULL ,
  prod_id    char(10 )     NOT NULL ,
  quantity   int          NOT NULL ,
  item_price decimal( 8,2 ) NOT NULL
);

...
...
...

```

> 모든 테이블이 잘 생성되었는지 확인

```
SELECT * FROM sys.tables ;
```

```
name        object_id   principal_id schema_id   parent_object_id type type_desc  ...  ----------- ----------- ------------ ----------- ---------------- ---- -----------...  Customers   245575913   NULL         1           0                U    USER_TABLE ...  OrderItems  261575970   NULL         1           0                U    USER_TABLE ...  Orders      277576027   NULL         1           0                U    USER_TABLE ...  Products    293576084   NULL         1           0                U    USER_TABLE ...  Vendors     309576141   NULL         1           0                U    USER_TABLE ...    (5개 행이 영향을 받음)
```

### 2-3. 데이타 INSERT

> 각 테이블에 데이타 INSERT 
> Populate Customers table

```
INSERT INTO Customers(cust_id , cust_name, cust_address, cust_city , cust_state, cust_zip, cust_country, cust_contact, cust_email)
VALUES('1000000001' , 'Village Toys' , '200 Maple Lane' , 'Detroit' , 'MI' , '44444' , 'USA' , 'John Smith', 'sales@villagetoys.com');
INSERT INTO Customers(cust_id , cust_name, cust_address, cust_city , cust_state, cust_zip, cust_country, cust_contact)
VALUES('1000000002' , 'Kids Place' , '333 South Lake Drive' , 'Columbus' , 'OH' , '43333' , 'USA', 'Michelle Green');
INSERT INTO Customers(cust_id , cust_name, cust_address, cust_city , cust_state, cust_zip, cust_country, cust_contact, cust_email)
VALUES('1000000003' , 'Fun4All' , '1 Sunny Place' , 'Muncie' , 'IN' , '42222' , 'USA' , 'Jim Jones', 'jjones@fun4all.com' );
INSERT INTO Customers(cust_id , cust_name, cust_address, cust_city , cust_state, cust_zip, cust_country, cust_contact, cust_email)
VALUES('1000000004' , 'Fun4All' , '829 Riverside Drive' , 'Phoenix' , 'AZ' , '88888' , 'USA' , 'Denise L. Stephens', 'dstephens@fun4all.com');
INSERT INTO Customers(cust_id , cust_name, cust_address, cust_city , cust_state, cust_zip, cust_country, cust_contact)
VALUES('1000000005' , 'The Toy Store' , '4545 53rd Street' , 'Chicago' , 'IL' , '54545' , 'USA' , 'Kim Howard');
```

> Populate Vendors table

```
INSERT INTO Vendors(vend_id , vend_name, vend_address, vend_city , vend_state, vend_zip, vend_country)
VALUES('BRS01' ,'Bears R Us', '123 Main Street','Bear Town' ,'MI', '44444', 'USA');
INSERT INTO Vendors(vend_id , vend_name, vend_address, vend_city , vend_state, vend_zip, vend_country)
VALUES('BRE02' ,'Bear Emporium', '500 Park Street','Anytown' ,'OH', '44333', 'USA');
INSERT INTO Vendors(vend_id , vend_name, vend_address, vend_city , vend_state, vend_zip, vend_country)
VALUES('DLL01' ,'Doll House Inc.', '555 High Street','Dollsville' ,'CA', '99999', 'USA');
INSERT INTO Vendors(vend_id , vend_name, vend_address, vend_city , vend_state, vend_zip, vend_country)
VALUES('FRB01' ,'Furball Inc.', '1000 5th Avenue','New York' ,'NY', '11111', 'USA');
INSERT INTO Vendors(vend_id , vend_name, vend_address, vend_city , vend_state, vend_zip, vend_country)
VALUES('FNG01' ,'Fun and Games', '42 Galaxy Road','London' , NULL, 'N16 6PS', 'England');
INSERT INTO Vendors(vend_id , vend_name, vend_address, vend_city , vend_state, vend_zip, vend_country)
VALUES('JTS01' ,'Jouets et ours', '1 Rue Amusement','Paris' , NULL, '45678', 'France');
```

> 각 테이블에 데이타 INSERT 
> Populate Customers table

```
INSERT INTO Customers(cust_id , cust_name, cust_address, cust_city , cust_state, cust_zip, cust_country, cust_contact, cust_email)
VALUES('1000000001' , 'Village Toys' , '200 Maple Lane' , 'Detroit' , 'MI' , '44444' , 'USA' , 'John Smith', 'sales@villagetoys.com');
INSERT INTO Customers(cust_id , cust_name, cust_address, cust_city , cust_state, cust_zip, cust_country, cust_contact)
VALUES('1000000002' , 'Kids Place' , '333 South Lake Drive' , 'Columbus' , 'OH' , '43333' , 'USA', 'Michelle Green');
INSERT INTO Customers(cust_id , cust_name, cust_address, cust_city , cust_state, cust_zip, cust_country, cust_contact, cust_email)
VALUES('1000000003' , 'Fun4All' , '1 Sunny Place' , 'Muncie' , 'IN' , '42222' , 'USA' , 'Jim Jones', 'jjones@fun4all.com' );
INSERT INTO Customers(cust_id , cust_name, cust_address, cust_city , cust_state, cust_zip, cust_country, cust_contact, cust_email)
VALUES('1000000004' , 'Fun4All' , '829 Riverside Drive' , 'Phoenix' , 'AZ' , '88888' , 'USA' , 'Denise L. Stephens', 'dstephens@fun4all.com');
INSERT INTO Customers(cust_id , cust_name, cust_address, cust_city , cust_state, cust_zip, cust_country, cust_contact)
VALUES('1000000005' , 'The Toy Store' , '4545 53rd Street' , 'Chicago' , 'IL' , '54545' , 'USA' , 'Kim Howard');
```

> Populate Vendors table

```
INSERT INTO Vendors(vend_id , vend_name, vend_address, vend_city , vend_state, vend_zip, vend_country)
VALUES('BRS01' ,'Bears R Us', '123 Main Street','Bear Town' ,'MI', '44444', 'USA');
INSERT INTO Vendors(vend_id , vend_name, vend_address, vend_city , vend_state, vend_zip, vend_country)
VALUES('BRE02' ,'Bear Emporium', '500 Park Street','Anytown' ,'OH', '44333', 'USA');
INSERT INTO Vendors(vend_id , vend_name, vend_address, vend_city , vend_state, vend_zip, vend_country)
VALUES('DLL01' ,'Doll House Inc.', '555 High Street','Dollsville' ,'CA', '99999', 'USA');
INSERT INTO Vendors(vend_id , vend_name, vend_address, vend_city , vend_state, vend_zip, vend_country)
VALUES('FRB01' ,'Furball Inc.', '1000 5th Avenue','New York' ,'NY', '11111', 'USA');
INSERT INTO Vendors(vend_id , vend_name, vend_address, vend_city , vend_state, vend_zip, vend_country)
VALUES('FNG01' ,'Fun and Games', '42 Galaxy Road','London' , NULL, 'N16 6PS', 'England');
INSERT INTO Vendors(vend_id , vend_name, vend_address, vend_city , vend_state, vend_zip, vend_country)
VALUES('JTS01' ,'Jouets et ours', '1 Rue Amusement','Paris' , NULL, '45678', 'France'); 
...
...
...
```

## 3. 데이타 검색, 조작

### 3-1. 컬럼정해서 SELECT

> 내림차순으로 정렬

```
USE hhddb;

SELECT prod_id, prod_price, prod_name
FROM Products
ORDER BY prod_price DESC;

```

```
prod_id    prod_price                              prod_name  ---------- --------------------------------------- ----------------------------------------  BR03       11.99                                   18 inch teddy bear                       RYL01      9.49                                    King doll                                RYL02      9.49                                    Queen doll                               BR02       8.99                                    12 inch teddy bear                       BR01       5.99                                    8 inch teddy bear                        RGAN01     4.99                                    Raggedy Ann                              BNBG01     3.49                                    Fish bean bag toy                        BNBG02     3.49                                    Bird bean bag toy                        BNBG03     3.49                                    Rabbit bean bag toy                    
```

### 3-2. 범위정해서 SELECT

```
SELECT prod_name, prod_price
FROM Products
WHERE prod_price BETWEEN 5 AND 10 ;
```

```
prod_name                                prod_price  ---------------------------------------- ---------------------------------------  8 inch teddy bear                        5.99  12 inch teddy bear                       8.99  King doll                                9.49  Queen doll                               9.49
```

### 3-3. IN 그룹안에서 조건걸어서 SELECT

```
SELECT prod_name, prod_price
FROM Products
WHERE vend_id IN ('DLL01' , 'BRS01' )
ORDER BY prod_name;
```

```
prod_name                                prod_price  ---------------------------------------- ---------------------------------------  12 inch teddy bear                       8.99  18 inch teddy bear                       11.99  8 inch teddy bear                        5.99  Bird bean bag toy                        3.49  Fish bean bag toy                        3.49  Rabbit bean bag toy                      3.49  Raggedy Ann                              4.99    (7개 행이 영향을 받음)
```

### 3-4. 부정절 조건으로 SELECT

```
SELECT prod_name
FROM Products
WHERE NOT vend_id = 'DLL01'
ORDER BY prod_id;
```

```
prod_name  ----------------------------------------  8 inch teddy bear                        12 inch teddy bear                       18 inch teddy bear                       King doll                                Queen doll                                 (5개 행이 영향을 받음)
```

### 3-5. LIKE 를 이용한 패턴 SELECT

> 와일드카드 문자 이용

```
SELECT prod_name
FROM Products
WHERE prod_name LIKE 'F%y';
```

```
prod_name  ----------------------------------------  Fish bean bag toy                      
```

### 3-6. LIKE를 이용한 패턴 SELECT

> 와일드카드문자 + 정규식이용

```
SELECT cust_contact
FROM Customers
WHERE cust_contact LIKE '[JM]%';
```

```
cust_contact  ----------------------------------------  John Smith                               Michelle Green                           Jim Jones                                  (3개 행이 영향을 받음)
```

### 3-7. 평균값을 구함

> AVG 함수 사용

```
SELECT AVG (prod_price) AS avg_price
FROM Products;
```

```
avg_price  ---------------------------------------  6.823333
```

### 3-8. 그룹핑하고 카운트를 구함

> GROUP BY 
> COUNT 함수 사용

```
SELECT vend_id, COUNT(*) as num_prod
FROM Products
GROUP BY vend_id;
```

```
vend_id    num_prod  ---------- -----------  BRS01      3  DLL01      4  FNG01      2
```

### 3-9. 그룹핑하고 카운트를 구하며, 그 그룹의 조건으로 필터링

> GROUP BY 
> COUNT 함수 
> HAVING
>
> - HAVING은 그룹에 대한 WHERE라고 생각하면 된다.

```
SELECT vend_id, COUNT(*) as num_prod
FROM Products
WHERE prod_price >= 4
GROUP BY vend_id
HAVING COUNT (*) >= 2;
```

```
vend_id    num_prod  ---------- -----------  BRS01      3  FNG01      2
```

### 3-10. IN 그룹을 SELECT쿼리로 중첩쿼리 만들어서 사용.

```
SELECT cust_id
FROM Orders
WHERE order_num IN
(
    SELECT order_num
    FROM OrderItems
    WHERE prod_id = 'RGAN01'
);
```

```
cust_id  ----------  1000000004  1000000005
```

### 3-11. 명시적인 INNER JOIN

```
SELECT vend_name, prod_name, prod_price
FROM Vendors INNER JOIN Products
ON Vendors. vend_id = Products .vend_id;
```

```
vend_name                                prod_name                                prod_price  ---------------------------------------- ---------------------------------------- ---------------------------------------  Doll House Inc.                          Fish bean bag toy                        3.49  Doll House Inc.                          Bird bean bag toy                        3.49  Doll House Inc.                          Rabbit bean bag toy                      3.49  Bears R Us                               8 inch teddy bear                        5.99  Bears R Us                               12 inch teddy bear                       8.99  Bears R Us                               18 inch teddy bear                       11.99  Doll House Inc.                          Raggedy Ann                              4.99  Fun and Games                            King doll                                9.49  Fun and Games                            Queen doll                               9.49
```

### 3-12. 암시적인 INNER JOIN

```
SELECT prod_name, vend_name, prod_price , quantity
FROM OrderItems, Products, Vendors
WHERE Products. vend_id = Vendors .vend_id
    AND OrderItems .prod_id = Products.prod_id
    AND order_num = 20007;
```

```
prod_name                                vend_name                                prod_price ...  ---------------------------------------- ---------------------------------------- -----------...  18 inch teddy bear                       Bears R Us                               11.99      ...  Fish bean bag toy                        Doll House Inc.                          3.49       ...  Bird bean bag toy                        Doll House Inc.                          3.49       ...  Rabbit bean bag toy                      Doll House Inc.                          3.49       ...  Raggedy Ann                              Doll House Inc.                          4.99       ...
```

### 3-13. 암시적인 INNER JOIN 에 컬럼이름 커스토마이즈

```
SELECT c. cust_name AS '고객이름', c .cust_contact AS '고객주소'
FROM Customers AS c, Orders AS o, OrderItems AS oi
WHERE c. cust_id = o .cust_id
    AND oi .order_num = o.order_num
    AND prod_id = 'RGAN01' ;
```

```
고객이름                                     고객주소  ---------------------------------------- ----------------------------------------  Fun4All                                  Denise L. Stephens                       The Toy Store                            Kim Howard                             
```

### 3-14. 명시적인 OUTER JOIN

> OUTER JOIN 은 명시적으로 JOIN기준축을 설정해 주어야 한다.

```
SELECT Customers. cust_id, Orders .order_num
FROM Customers LEFT OUTER JOIN Orders
ON Customers. cust_id = orders .cust_id;
```

```
cust_id    order_num  ---------- -----------  1000000001 20005  1000000001 20009  1000000002 NULL  1000000003 20006  1000000004 20007  1000000005 20008
```

### 3-15. 두 결과를 병합 UNION

> UNION 과정에서 중복데이타는 제거된다.

```
(
    SELECT cust_name , cust_contact
    FROM Customers
    WHERE cust_state IN ( 'IL', 'IN', 'MI')
)
UNION
(
    SELECT *
    FROM Customers
    WHERE cust_name = 'Fun4All'
);
```

```
cust_id    cust_name                                cust_address                             cust_city    ...  ---------- ---------------------------------------- ---------------------------------------- -------------...  1000000001 Village Toys                             200 Maple Lane                           Detroit      ...  1000000003 Fun4All                                  1 Sunny Place                            Muncie       ...  1000000004 Fun4All                                  829 Riverside Drive                      Phoenix      ...  1000000005 The Toy Store                            4545 53rd Street                         Chicago      ...
```

### 3-16. 스키마가 똑같은 테이블을 만들어서 모든내용 복사

```
DROP TABLE CustomersNew;

CREATE TABLE CustomersNew
(
  cust_id      char(10 )  NOT NULL ,
  cust_name    char(50 )  NOT NULL ,
  cust_address char( 50)  NULL ,
  cust_city    char(50 )  NULL ,
  cust_state   char(5 )   NULL ,
  cust_zip     char(10 )  NULL ,
  cust_country char( 50)  NULL ,
  cust_contact char( 50)  NULL ,
  cust_email   char(255 ) NULL
);

INSERT INTO CustomersNew
SELECT *
FROM Customers;

SELECT *
FROM CustomersNew;
```

```
(5개 행이 영향을 받음)  cust_id    cust_name                                cust_address                             cust_city ...  ---------- ---------------------------------------- ---------------------------------------- ----------...  1000000001 Village Toys                             200 Maple Lane                           Detroit   ...  1000000002 Kids Place                               333 South Lake Drive                     Columbus  ...  1000000003 Fun4All                                  1 Sunny Place                            Muncie    ...  1000000004 Fun4All                                  829 Riverside Drive                      Phoenix   ...  1000000005 The Toy Store                            4545 53rd Street                         Chicago   ...    (5개 행이 영향을 받음)
```

### 3-17. 데이타 업데이트

```
UPDATE Customers
SET cust_email = 'kim@thetoystore.com'
WHERE cust_id = '1000000005';

SELECT *
FROM Customers
WHERE cust_id = '1000000005';
```

```
(1개 행이 영향을 받음)  cust_id    cust_name                                cust_address                             cust_city ...  ---------- ---------------------------------------- ---------------------------------------- ----------...  1000000005 The Toy Store                            4545 53rd Street                         Chicago   ...    (1개 행이 영향을 받음)
```

### 3-18. 데이타 삭제

```
SELECT * FROM CustomersNew
WHERE cust_id = '1000000005';
```

```
cust_id    cust_name                                cust_address                             cust_city   ...  ---------- ---------------------------------------- ---------------------------------------- ------------...  1000000005 The Toy Store                            4545 53rd Street                         Chicago     ...                                                                                                             ...  (1개 행이 영향을 받음)                                                                                   ...
```

```
DELETE FROM CustomersNew
WHERE cust_id = '1000000005';
```

```
(1개 행이 영향을 받음)                                                                                   ...
```

```
SELECT * FROM CustomersNew
WHERE cust_id = '1000000005';
```

```
cust_id    cust_name                                cust_address                             cust_city   ...  ---------- ---------------------------------------- ---------------------------------------- ------------...    (0개 행이 영향을 받음)
```

### 3-19. 테이블에서 컬럼추가, 컬럼삭제

> 테이블의 모든 컬럼보기

```
SELECT *
FROM INFORMATION_SCHEMA .COLUMNS
WHERE TABLE_NAME = 'Vendors';
```

```
TABLE_CATALOG           TABLE_SCHEMA  TABLE_NAME  COLUMN_NAME   ...  ----------------------- ------------- ----------- --------------...  hhddb                   dbo           Vendors     vend_id       ...  hhddb                   dbo           Vendors     vend_name     ...  hhddb                   dbo           Vendors     vend_address  ...  hhddb                   dbo           Vendors     vend_city     ...  hhddb                   dbo           Vendors     vend_state    ...  hhddb                   dbo           Vendors     vend_zip      ...  hhddb                   dbo           Vendors     vend_country  ...                                                                   ...  (7개 행이 영향을 받음)                                          ...
```

```
alter table Vendors
add vend_phone char (20);

SELECT *
FROM INFORMATION_SCHEMA .COLUMNS
WHERE TABLE_NAME = 'Vendors';
```

```
TABLE_CATALOG           TABLE_SCHEMA  TABLE_NAME  COLUMN_NAME   ...  ----------------------- ------------- ----------- --------------...  hhddb                   dbo           Vendors     vend_id       ...  hhddb                   dbo           Vendors     vend_name     ...  hhddb                   dbo           Vendors     vend_address  ...  hhddb                   dbo           Vendors     vend_city     ...  hhddb                   dbo           Vendors     vend_state    ...  hhddb                   dbo           Vendors     vend_zip      ...  hhddb                   dbo           Vendors     vend_country  ...  hhddb                   dbo           Vendors     vend_phone    ...                                                                  ...  (8개 행이 영향을 받음)                                          ...
```

```
alter table Vendors
drop column vend_phone;

SELECT *
FROM INFORMATION_SCHEMA .COLUMNS
WHERE TABLE_NAME = 'Vendors';
```

```
TABLE_CATALOG           TABLE_SCHEMA  TABLE_NAME  COLUMN_NAME   ...  ----------------------- ------------- ----------- --------------...  hhddb                   dbo           Vendors     vend_id       ...  hhddb                   dbo           Vendors     vend_name     ...  hhddb                   dbo           Vendors     vend_address  ...  hhddb                   dbo           Vendors     vend_city     ...  hhddb                   dbo           Vendors     vend_state    ...  hhddb                   dbo           Vendors     vend_zip      ...  hhddb                   dbo           Vendors     vend_country  ...    (7개 행이 영향을 받음)
```

### 3-20. 저장프로시저 생성/실행/삭제

```
CREATE PROCEDURE sp_new_order @cust_id CHAR( 10)
AS
    DECLARE @order_num INTEGER;

    SELECT @order_num = MAX (order_num)
    FROM Orders ;

    SELECT @order_num = @order_num + 1;

    INSERT INTO Orders( order_num, order_date , cust_id)
    VALUES( @order_num, GETDATE(), @cust_id );

    RETURN @order_num ;
GO

SELECT * FROM sys.procedures ;
```

```
name                                     object_id   principal_id schema_id   parent_object_id type type_desc                                ...  ---------------------------------------- ----------- ------------ ----------- ---------------- ---- ---------------------------------------- ...  sp_new_order                             869578136   NULL         1           0                P    SQL_STORED_PROCEDURE                     ...
```

```
SELECT * FROM Orders ;
```

```
order_num   order_date              cust_id  ----------- ----------------------- ----------  20005       2004-05-01 00:00:00.000 1000000001  20006       2004-01-12 00:00:00.000 1000000003  20007       2004-01-30 00:00:00.000 1000000004  20008       2004-02-03 00:00:00.000 1000000005
```

```
EXECUTE sp_new_order '1000000001';
EXECUTE sp_new_order '1000000001';
EXECUTE sp_new_order '1000000001';

SELECT * FROM Orders ;
```

```
order_num   order_date              cust_id  ----------- ----------------------- ----------  20005       2004-05-01 00:00:00.000 1000000001  20006       2004-01-12 00:00:00.000 1000000003  20007       2004-01-30 00:00:00.000 1000000004  20008       2004-02-03 00:00:00.000 1000000005  20009       2004-02-08 00:00:00.000 1000000001  20010       2015-10-01 14:20:39.107 1000000001  20011       2015-10-01 14:20:39.113 1000000001
```

```
DROP PROCEDURE sp_new_order;
```

### 3-21. 트렌젝션을 설정하고 도중에 실패한 경우 롤백까지

> 이 예제에서는 작업진행하다가 중간에 Orders 테이블에서 삭제시 FK제약사항 때문에 예외가 발생하고 이 때문에 롤백됨.

```
BEGIN TRANSACTION ;
SAVE TRANSACTION start_point;

SELECT *
FROM OrderItems;
```

```
order_num   order_item  prod_id    quantity    item_price  ----------- ----------- ---------- ----------- ---------------------------------------  20005       1           BR01       100         5.49  20005       2           BR03       100         10.99  20006       1           BR01       20          5.99  20006       2           BR02       10          8.99  20006       3           BR03       10          11.99  20007       1           BR03       50          11.49  20007       2           BNBG01     100         2.99  20007       3           BNBG02     100         2.99  20007       4           BNBG03     100         2.99  20007       5           RGAN01     50          4.49  20008       1           RGAN01     5           4.99  20008       2           BR03       5           11.99  20008       3           BNBG01     10          3.49  20008       4           BNBG02     10          3.49  20008       5           BNBG03     10          3.49  20009       1           BNBG01     250         2.49  20009       2           BNBG02     250         2.49  20009       3           BNBG03     250         2.49
```

```
DELETE OrderItems
WHERE order_num = 20005;

SELECT *
FROM OrderItems;
```

```
order_num   order_item  prod_id    quantity    item_price  ----------- ----------- ---------- ----------- ---------------------------------------  20006       1           BR01       20          5.99  20006       2           BR02       10          8.99  20006       3           BR03       10          11.99  20007       1           BR03       50          11.49  20007       2           BNBG01     100         2.99  20007       3           BNBG02     100         2.99  20007       4           BNBG03     100         2.99  20007       5           RGAN01     50          4.49  20008       1           RGAN01     5           4.99  20008       2           BR03       5           11.99  20008       3           BNBG01     10          3.49  20008       4           BNBG02     10          3.49  20008       5           BNBG03     10          3.49  20009       1           BNBG01     250         2.49  20009       2           BNBG02     250         2.49  20009       3           BNBG03     250         2.49
```

```
SELECT *
FROM Orders;
```

```
order_num   order_date              cust_id  ----------- ----------------------- ----------  20005       2004-05-01 00:00:00.000 1000000001  20006       2004-01-12 00:00:00.000 1000000003  20007       2004-01-30 00:00:00.000 1000000004  20008       2004-02-03 00:00:00.000 1000000005  20009       2004-02-08 00:00:00.000 1000000001
```

```
DELETE Orders
WHERE order_num = 20005;
```

(1개 행이 영향을 받음)

```
SELECT *
FROM Orders;
```

```
order_num   order_date              cust_id  ----------- ----------------------- ----------  20006       2004-01-12 00:00:00.000 1000000003  20007       2004-01-30 00:00:00.000 1000000004  20008       2004-02-03 00:00:00.000 1000000005  20009       2004-02-08 00:00:00.000 1000000001
```

```
DELETE Orders
WHERE order_num = 20006;

IF @@ERROR <> 0
BEGIN
    PRINT N'에러 발생함 start_point 로 롤백함...' ;
    ROLLBACK TRANSACTION start_point;
END
```

메시지 547, 수준 16, 상태 0, 줄 22  DELETE 문이 REFERENCE 제약 조건 "FK_OrderItems_Orders"과(와) 충돌했습니다. 데이터베이스 "hhddb", 테이블 "dbo.OrderItems", column 'order_num'에서 충돌이 발생했습니다.  문이 종료되었습니다.  에러 발생함 start_point 로 롤백함...

```
SELECT *
FROM Orders;
```

```
order_num   order_date              cust_id  ----------- ----------------------- ----------  20005       2004-05-01 00:00:00.000 1000000001  20006       2004-01-12 00:00:00.000 1000000003  20007       2004-01-30 00:00:00.000 1000000004  20008       2004-02-03 00:00:00.000 1000000005  20009       2004-02-08 00:00:00.000 1000000001
```

```
COMMIT TRANSACTION ;
```

### 3-22. 인덱스 생성/확인/삭제

```
SELECT *
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME = 'Products';

CREATE INDEX idx_prod_name
ON Products( prod_name);

SELECT *
FROM sys.indexes
WHERE name LIKE 'idx_%';

DROP INDEX idx_prod_name
ON Products;

TABLE_CATALOG  TABLE_SCHEMA  TABLE_NAME  COLUMN_NAME  ...  -------------- ------------- ----------- -------------...  hhddb          dbo           Products    prod_id      ...  hhddb          dbo           Products    vend_id      ...  hhddb          dbo           Products    prod_name    ...  hhddb          dbo           Products    prod_price   ...  hhddb          dbo           Products    prod_desc    ...    (5개 행이 영향을 받음)    object_id   name           index_id    type type_desc      is_unique data_space_id ...  ----------- -------------- ----------- ---- -------------- --------- ------------- ...  293576084   idx_prod_name  2           2    NONCLUSTERED   0         1             ...    (1개 행이 영향을 받음)  ...
```