## 웹개발 시험 준비 

### 쿠키와 세션

#### 1. 쿠키

- 클라이언트에 저장되는 키와 값이 들어있는 작은 데이터 파일
- 쿠키는 이름, 값, 만료 날짜(쿠키 저장기간), 경로 정보가 들어있다.
- 쿠키는 일정 시간동안 데이터를 저장할 수 있어서 로그인 상태를 유지함.
- 쿠키는 클라이언트의 상태 정보를 본인 하드 디스크에 저장하였다가 필요할 때 참조, 재사용함.

#### 1. 2) 쿠키의 사용 예

- 방문 사이트에서 아이디와 비밀번호를 저장하시겠습니까? 라고 나타나는 것은 쿠키로 저장하겠냐 라는 뜻
- 팝업이 나타날때 "오늘 이 창을 보지 않음"을 누르면 오늘 그 창이 뜨지 않는 것.

#### 1.3) 쿠키의 제약조건

- 클라이언트에 총 300개까지 쿠키를 저장할 수 있음 !
- 하나의 도메인 당 20개의 값만 가질 수 있음 !
- 하나의 쿠키 값은 4MB까지 저장 가능 !

### 2. 세션

- 세션은 클라이언트와 웹 서버간 네트워크 연결이 지속 유지되고 있는 상태
- 즉, 사용자가 브라우저를 열어 서버에 접속한 뒤 접속을 종료할 때 시점까지를 말함.
- HTTP 프로토콜은 비접속형 프로토콜이므로, 매 접속시마다 새로운 네트워크 연결이 이루어지는데, 세션이 연결유지를 가능하게 해줌.
- 클라이언트가 웹서버에 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여, 이 ID를 세션이라고 부름
- 세션 ID는 임시로 저장하여 페이지 이동 시 이용하거나, 클라이언트가 재 접속 했을 때 클라이언트를 유일하게 구분하는 수단.

#### 2.2) 세션의 장점

- 각 클라이언트에게 고유 ID를 부여함 (정확한 구분)
- 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
- 서버에서 클라이언트롤 발급해준 세션 ID를 쿠키를 사용해서 저장
- 클라이언트는 다시 접속시, 이 쿠키를 이용해서 세션 ID값을 서버에 전달함.

#### 2.3) 세션의 단점

- 서버에 저장되는 세션때문에 서버에 처리를 요구하는 부하와 저장 공간을 필요함.

#### 2.4) 사용 예

- 로그인과 같이 보안상 중요한 작업은 세션을 통해서 작동함. 

#### 쿠키와 세션의 차이점

기본적으로 쿠키와 세션은 비슷한 역할을 함, 동작원리 또한 비슷, 왜냐하면 세션도 결국 쿠키로 저장해서 사용하기 때문이다.

그러나 큰 차이점은 저장되는 위치. 쿠키는 클라이언트에 저장되어서 보내는 역할을하고, 세션은 서버에 저장되어서 클라이언트에게 알려줘서 사용함. 

쿠키는 서버의 자원을 전혀 사용하지 않으며 클라이언트 단에서 저장을 해서 사용. 

세션은 서버에 저장되어서 그 고유한 ID를 가지고 있음. 그래서 서버의 자원을 사용

쿠키와 세션은 서버의 자원을 사용할 수 있음. 쿠키와 세션의 만료되는 기간도 다름.

쿠키는 클라이언트에 저장되어서 서버에 요청시 빠른 속도를 보냄. 세션은 서버에 정보가 있기때문에 서버의 처리가 필요해서 쿠키보다 느린 속도.

#### 보안성이 낮은 Cookie 대신 Session을 사용하면 되는데 안하는 이유?

모든 정보를 **Session에 저장하면 Server의 메모리를 과도하게 사용하게 되어 Server에 무리**가 감

---

### Restful API란 ?

Representational State Transfer API

#### 1. Rest 구성

- 자원(Resource) - URL
- 행위(Verb) - HTTP METHOD
- 표현(Representations)

#### 2. Rest의 특징

**1) Uniform (유니폼 인터페이스)**

Uniform Interface는 URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말합니다.

**2) Stateless (무상태성)**

REST는 무상태성 성격을 갖습니다. 다시 말해 작업을 위한 상태정보를 따로 저장하고 관리하지 않습니다. 세션 정보나 쿠키정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 단순히 처리하면 됩니다. 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해집니다.

**3) Cacheable (캐시 가능)**

REST의 가장 큰 특징 중 하나는 HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능합니다. 따라서 HTTP가 가진 캐싱 기능이 적용 가능합니다. HTTP 프로토콜 표준에서 사용하는 Last-Modified태그나 E-Tag를 이용하면 캐싱 구현이 가능합니다.

**4) Self-descriptiveness (자체 표현 구조)**

REST의 또 다른 큰 특징 중 하나는 REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조로 되어 있다는 것입니다.

**5) Client - Server 구조**

REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 됩니다.

**6) 계층형 구조**

REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 합니다.

#### 3. Rest API 디자인 가이드

**첫 번째,** URI는 정보의 자원을 표현해야 한다.
**두 번째,** 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다.

#### 결론 

**진짜 사람이 말하는 것처럼 url을 바꾸기 위한 국제적인 웹 개발 규약(?) 약속이다 !**

---

### MVC 패턴

#### MVC란?

- 객체지향프로그래밍에서, MVC란 사용자 인터페이스를 성공적이며 효과적으로 데이터 모형에 관련 시키기 위한 방법론 또는 설계 방식중 하나이다. MVC방식은 자바, Smalltalk,
- MVC 패턴은 목적 코드의 재사용에 유용한 것은 물론, 사용자 인터페이스와 응용프로그램 개발에 소요되는 시간을 현저하게 줄여주는 형식이라고 많은 개발자들이 평가하고 있다.

#### MVC 구성요소

**Model** 

- 소프트웨어 응용과 그와 관련된 고급 클래스 내의 **논리적 데이터 기반 구조를 표현**. 이 목적 모형은 사용자 인터페이스에 관한 어떠한 정보도 가지고 있지 않다.

**View **

- 사용자 인터페이스 내의 구성요소들을 표현(**사용자에게 보여지는 화면**)

**Controller **

- Model과 View를 연결하고 있는 클래스를 대표, **Model과 View 내의 클래스들 간 정보 교환**하는데 사용

---

### RDBMS와 NO SQL 

#### 1. RDBMS 란 ?

관계형 데이터베이스는 데이터 항목 간에 사전 정의된 관계가 있을 때 그러한 데이터 항목들의 모음을 가리킵니다. 이들 항목은 열과 행으로 이루어진 테이블 집합으로 구성됩니다. 테이블은 데이터베이스에 표시할 해당 객체들에 관한 정보를 수록하는 데 사용됩니다. 테이블의 각 열은 특정 종류의 데이터를 수록하며 필드는 속성의 실제 값을 저장합니다. 테이블의 행은 한 객체 또는 엔터티와 관련된 값들의 모음을 나타냅니다. 테이블의 각 행은 기본 키라고 부르는 고유 식별자로 표시할 수 있고 여러 테이블에 있는 행들은 외래 키를 사용하여 상호 연결될 수 있습니다. 이 데이터는 데이터베이스 테이블 자체를 재구성하지 않고도 여러 가지 방법으로 액세스할 수 있습니다.



즉, **RDBMS는 관계형 데이터베이스를 생성하고 수정하고 관리할 수 있는 소프트웨어라고 정의할 수 있습니다.**



#### 1. 2) 특징

- 모든 데이터를 2차원 테이블로 표현
- 테이블은 row(record, tuple)과 column(field, item)으로 이루어진 기본 데이터 저장 단위
- 상호관련성을 가진 테이블(table)의 집합
- 만들거나 이용하기도 비교적 쉽지만, 무엇보다도 확장이 용이하다는 장점을 가짐
- 데이터베이스의 설계도를 ER(Entity Relationship) 모델
- ER모델에 따라, 데이터베이스가 만들어지며, 데이터베이스는 하나 이상의 테이블로 구성 됨. ER모델에서 엔티티를 기반으로 테이블이 만들어짐



#### 2. No SQL이란 ?

NoSQL은 고성능 비관계형 데이터베이스를 설명하는 데 사용되는 용어입니다. NoSQL 데이터베이스는 문서, 그래프, 키-값, 컬럼 형식 등을 비롯한 다양한 데이터 모델을 사용합니다. NoSQL 데이터베이스는 배포 용이성, 확장 가능한 성능, 고가용성 및 복원력으로 널리 인정받고 있습니다. 아래는 NoSQL 데이터베이스 사용을 시작하는 데 도움이 되는 몇 가지 리소스입니다.

NoSQL이 무엇의 약자인지는 사람에 따라 NoSQL, Not Only SQL, Non-Relational Operational Database SQL로 엇갈리는 의견들이 있습니다만, 현재 Not Only SQL로 풀어 설명하는 것이 다수를 차지하고 있다고 합니다.

이 말의 의미를 풀어보면, **기존의 관계형 DBMS가 갖고있는 특성 뿐만 아니라 다른 특성들을 부가적으로 지원한다는 것**을 의미합니다.



#### 2. 2) NoSQL의 특징

**NoSQL 데이터베이스는 기존의 관계형 데이터베이스보다 더 융통성있는 데이터 모델을 사용하고 데이터의 저장 및 검색을 위한 특화된 메커니즘을 제공**합니다. 이를 통해 NoSQL 데이터베이스는 단순 검색 및 추가작업에 있어서 매우 최적화된 키 값 저장 기법을 사용하여 **응답속도나 처리효율 등에 있어서 매우 뛰어난 성능**을 나타냅니다.



#### 3. RDBMS와 No SQL의 차이점

NoSQL의 차별화된 특징은 RDBMS와 다르게 최초 테이블 생성 시 데이터간의 관계를 정의하지 않습니다. 때문에 보다 빠른 속도의 설계가 가능했습니다. 또한 RDBMS가 가지고 있던 복잡도와 용량의 한계를 극복하며 페타바이트 그 이상 급의 대용량 데이터를 저장할 수 있게 되었습니다.

NoSQL은 Scale Out을 통한 노드 확장을 지원합니다. 하나의 고성능 머신이 데이터서버가 되어 처리하는 Scale Up 방식의  RDBMS와 달리 여러개의 일반 서버를 연결하여 데이터를 분산하고 저장하게 됩니다. 이를 통해 보다 안정성이 확보됩니다.

---

### TCP와 UDP

#### 1. TCP(Transmission Control Protocol)

- 연결형 서비스를 지원하는 전송계층 프로토콜
- 인터넷 환경에서 기본으로 사용한다.
- 호스트간 신뢰성 있는 데이터 전달과 흐름제어 및 혼잡제어 등을 제공하는 전송계층

#### 1. 2) 특징

- 가상 회선 연결 방식, 연결형 서비스를 제공
- 높은 신뢰성(Sequence Number, Ack Number를 통한 신뢰성 보장)
- 연결의 설정(3-way handshaking)과 해제(4-way handshaking)
- 데이터 흐름 제어(수신자 버퍼 오버플로우 방지) 및 혼잡 제어(네트워크 내 패킷 수가 과도하게 증가하는 현상 방지)
- 전이중(Full-Duplex), 점대점(Point to Point) 서비스

####1. 3) 소켓 통신 과정

- 서버 : 소켓을 생성, 주소 할당, 연결 요청 기다림, 요청에 대한 응답
- 클라이언트 : 소켓을 생성, 주소 할당, 연결 요청

#### 2. UDP(User Datagram Protocol)

- 비연결형 서비스를 지원하는 전송계층 프로토콜
- 사용자 데이터그램형 프로토콜
- 인터넷상에서 서로 정보를 주고받을 때 정보를 보낸다는 신호나 받는다는 신호 절차를 거치지 않고,
- 보내는 쪽에서 일방적으로 데이터를 전달하는 통신 프로토콜
- 보내는 쪽에서는 받는 쪽이 데이터를 받았는지 받지 않았는지 확인할 수 없고, 또 확인할 필요도 없도록 만들어진 프로토콜

####2. 2) 특징

- 비연결형(port만 확인하여 소켓을 식별하고 송수신)
- 패킷 오버헤드가 적어 네트워크 부하 감소
- 비신뢰성
- 오류검출(헤더에 오류 검출 필드를 포함하여 무결성 검사)
- TCP의 handshaking 같은 연결 설정이 없다
- DNS, NFS, SNMP, RIP 등 사용

####2. 3) 소켓 통신 과정

- 서버 : 소켓을 생성, 주소 할당, 데이터를 송수신
- 클라이언트 : 소켓 생성 후 데이터 수신

#### 3. TCP와 UDP 차이점

UDP는 TCP와 달리 데이터의 수신에 대한 책임을 지지 않는다.

이는 송신자는 정보를 보냈지만, 정보가 수신자에게 제때에 도착했는지 또는 정보 내용이 서로 뒤바뀌었는지에 관해서 송신자는 상관할 필요가 없다.

TCP보다 안정성 면에서는 떨어지지만, 속도는 훨씬 빠르다.

---

### DBMS 인덱스

####DBMS의 Index란?

데이터베이스에서 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유하고 있는 객체(object)이다. 

사용자는 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 인덱스를 생성하고 사용한다. 

---

### SQL NOT EXISTS와 JOIN

NOT EXISTS 사용

```
SELECT
  t_main.*
FROM t_main 
WHERE 
  NOT EXISTS (
    SELECT t_related.id 
    FROM t_related 
    WHERE t_main.id = t_related.id
  )
```

LEFT OUTER JOIN 사용

```
SELECT 
  t_main.*,
FROM 
   t_main
   LEFT OUTER JOIN t_related ON t_main.id = t_related.id
/* IS NULL in the WHERE clause */
WHERE t_related.id IS NULL
```

---

### G2B, B2B, C2C ... 란 ?

B2B - 기업과 기업간의 전자상거래

B2C - 기업과 소비자 간의 전자상거래

G2B - 정부와 기업 간의 전자상거래

G2C - 정부와 소비자 간의 전자상거래

C2C - 소비자와 소비자 간의 전자상거래

---

### BFS 너비 우선 탐색 알고리즘

먼저 BFS는 큐를 사용한다.

```java
public static void bfs(int[][] a, boolean[] c, int v) {
    Queue<Integer> q = new LinkedList<>();
    int n = a.length - 1;

    q.add(v);
    c[v] = true;

    while (!q.isEmpty()) {

        v = q.poll();
        System.out.print(v + " ");

        for (int i = 1; i <= n; i++) {

            if (a[v][i] == 1 && !c[i]) {
                q.add(i);
                c[i] = true;
            }

        }
    }
}
```

BFS의 경우는 아래와 같다.

1. 큐의 front인 정점을 기준으로 연결된 간선이 있고, 방문하지 않은 정점을 찾는다.
2. 조건에 맞는 정점은 모두 큐에 넣는다.

위 과정을 반복한다.

 BFS는 모두 큐에 넣음으로써 이름처럼 너비를 기준으로 탐색한다.

그렇기에 모든 경우를 탐색할 수 있게 됨으로써, 최단 경로에 이용한다고도 말을 할 수 있는 것이다.



마지막으로 인접 리스트를 조금 더 보겠다.

위에서 공간복잡도를 통해 인접행렬과 비교를 해보았다.

시간복잡도 측면에서도 효율적이다. 이유를 보자.

```
while(!q.isEmpty()) {
    v = q.poll();
    System.out.print(v + " ");

    for (int vv : a[v]) {

        if (!c[vv]) {
            q.add(vv);
            c[vv] = true;
        }

    }

}
```

인접 행렬의 경우 정점을 탐색하는 과정에서 무조건 1에서 n까지 루프를 돌았다.

인접 리스트의 경우에는 리스트 특성상 각 리스트마다 존재하는 정점만큼 존재한다.

그렇기에 i에서 n까지 돌지 않아도 되고, 위와 같이 존재하는 만큼만 탐색하면 된다.

출처:  http://mygumi.tistory.com/102